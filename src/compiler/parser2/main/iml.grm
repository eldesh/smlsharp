(* a grammar for the raw symtax of IML.
 * @copyright (c) 2006, Tohoku University.
 * @author Atsushi Ohori, Kiyoshi Yamatodani, Liu Bochao
 * @version $Id: iml.grm,v 1.69.6.8 2010/02/10 05:17:29 hiro-en Exp $

 * Ohori: 2007/11/11
 * WARNING: Large part of this file is copied to interface.grm.
 * I indicates those positons that are from iml.grm in interface.grm.
 * iml.grm is the original. If one change something there, he/she 
 * must propagate the change here. 
 * This is unsatisfactory situation. We will consider a better
 * organization later.

 * Ohori: 2012/10/9
   id, longid are systematically changed to symbol and longsymbol 
   having location information.

 * Ohori: 2012/12/28
   Format comments are added. They are largely copied from 
   in src/smlformat/generate/main/ml.grm.


 * Ohori: 2013/06/29
   Changed id to represent symbols.

*)

fun stripComment {formatComments, tyvars, tyConSymbol, ty} =
    (tyvars, tyConSymbol, ty)

%%

%decompose (yes)

%blocksize (40)

%eop EOF SEMICOLON

(* %pos declares the type of positions for terminals.
   Each symbol has an associated left and right position. *)

%pos Loc.pos

%term EOF
    | ABSTYPE
    | AND
    | ANDALSO 
    | ARROW
    | AS
    | ASTERISK
    | AT
    | ATTRIBUTE
    | BAR
    | BUILTIN
    | CASE
    | CHAR of string
    | COLON
    | COMMA
    | DARROW
    | DATATYPE
    | DO 
    | ELSE 
    | END
    | EQ
    | EQTYPE
    | EQTYVAR of string 
    | EXCEPTION
    | FFIAPPLY
    | FN 
    | FUN
    | FUNCTOR
    | HANDLE 
    | HASH
    | ID of string
    | IF 
    | IN
    | IMPORT
    | INCLUDE
    | INFIX
    | INFIXR
    | INT of {radix:StringCvt.radix, digits:string}
    | INTLAB of string
    | INTERFACE
(* temporary *)
    | JOIN
    | LBRACE
    | LBRACKET
    | LET
    | LOCAL
    | LPAREN
    | NONFIX
    | OF 
    | OP 
    | OPAQUE
    | OPEN
    | ORELSE
    | NULL
    | PERIOD
    | PERIODS
    | RAISE 
    | REC
    | POLYREC
    | REQUIRE
    | RBRACE
    | RBRACKET
    | REAL of string
    | RPAREN
    | SEMICOLON
    | SHARING
    | SIG
    | SIGNATURE
    | SIZEOF
    | SPECIAL of string
    | STRING of string
    | STRUCT
    | STRUCTURE
    | THEN 
    | TYPE
    | TYVAR of string 
    | UNDERBAR
    | USE
    | USE'
    | VAL
    | WHILE 
    | WHERE
    | WITH
    | WITHTYPE
    | WORD of {radix:StringCvt.radix, digits:string}

    | SQLSERVER
    | SQLEVAL
    | SQLEXEC
    | SQL
    | ASC
    | DESC
    | SELECT
    | FROM
    | INSERT
    | INTO
    | VALUES
    | DELETE
    | ORDER
    | BY
    | UPDATE
    | SET
    | DEFAULT
    | BEGIN
    | COMMIT
    | ROLLBACK

    | DITTOTAG
    | PREFIXTAG
    | DESTINATIONTAG 
    | HEADERTAG
    | FORMATCOMMENTSTART 
    | FORMATCOMMENTEND
    | FORMATTERTAG 
    | FORMATPARAMSTAG 
    | FORMATTAG 
    | LOCALFORMATTAG of string
    | NEWLINE
    | STARTOFINDENT of int
    | FORMATINDICATOR of
      {
        space : bool,
        newline : {priority : FormatTemplate.priority} option
      }
    | ASSOCINDICATOR of
      {cut : bool, strength : int, direction : FormatTemplate.assocDirection}


%nonterm id of Symbol.symbol
       | id_noEQ of Symbol.symbol
       | id_noEQSTAR of Symbol.symbol
       | id_noSQL of Symbol.symbol

       | longid of Symbol.longsymbol
       | longid_noSQL of Symbol.longsymbol
       | tylongid of Symbol.longsymbol

       | label of string

(*
       | longtyconid of Symbol.longsymbol
       | expid of Symbol.longsymbol
       | symbol of Symbol.symbol
       | symbol_noEQSTAR of Symbol.symbol
       | symbol_noSQL of Symbol.symbol
       | longsymbol of Symbol.longsymbol
       | longtycon of Symbol.longsymbol
       | explongsymbol of Symbol.longsymbol
       | explongsymbol_noSQL of Symbol.longsymbol
       | tylongsymbol of Symbol.longsymbol
       | symbolseq of Symbol.symbol list
       | longsymbolseq of Symbol.longsymbol list
       | longsymboleqrow of Symbol.longsymbol list
*)
       | idseq of Symbol.symbol list
       | longidseq of Symbol.longsymbol list
       | longideqrow of Symbol.longsymbol list

       | appexp of Absyn.exp
       | appexp_noSQL of Absyn.exp
       | atexp of Absyn.exp
       | atexp_noVAR of Absyn.exp
       | atexp_noSQL of Absyn.exp
       | atpat of Absyn.pat
       | apppat of Absyn.pat list
       | atomicspec of Absyn.spec
       | constant of Absyn.constant
       | condec of 
          {opFlag:bool,
           conSymbol:Symbol.symbol,
           tyOpt:Absyn.ty option,
           formatComments:Absyn.definingFormatComment list
           }
       | exndec of bool * Symbol.symbol * Absyn.ty option
       | combind of
          {opFlag:bool,
           conSymbol:Symbol.symbol,
           tyOpt:Absyn.ty option,
           formatComments:Absyn.definingFormatComment list
           } list
       | condesc of (Symbol.symbol * Absyn.ty option) list
       | dec of Absyn.dec
       | decs of Absyn.dec list
       | decseq_semicolon of Absyn.dec list
       | datbind of
         {
          tyvars : Absyn.tvar list, 
          tyConSymbol:Symbol.symbol,
          rhs : {opFlag:bool,
                 conSymbol:Symbol.symbol,
                 tyOpt:Absyn.ty option,
                 formatComments:Absyn.definingFormatComment list
                } list

         } list
       | datdesc of
         (Absyn.tvar list * Symbol.symbol * (Symbol.symbol * Absyn.ty option) list) list
       | exprow of (string * Absyn.exp) list
       | expseq_comma of Absyn.exp list
       | expseq_semicolon of Absyn.exp list
       | exp of Absyn.exp
       | expOrSQL of Absyn.exp
       | export of Symbol.longsymbol
       | exbinds of Absyn.exbind list
       | exbind of Absyn.exbind
       | exdesc of (Symbol.symbol * Absyn.ty option) list
       | fields of bool * (Absyn.patrow list)
       | followpatrow of Absyn.patrow list
       | fvalbind of {fdecl:(Absyn.pat list * Absyn.ty option * Absyn.exp) list, loc:Loc.loc} list
       | frule of Absyn.pat list * Absyn.ty option * Absyn.exp
       | frules of (Absyn.pat list * Absyn.ty option * Absyn.exp) list
       | funbind of Absyn.funbind
       | funbindand of Absyn.funbind
       | funbindseq of Absyn.funbind list
       | int of {radix:StringCvt.radix, digits:string}
       | longtyconeqrow of Symbol.longsymbol list
       | match of (Absyn.pat * Absyn.exp) list
       | mrule of Absyn.pat * Absyn.exp
       | optaspat of Absyn.pat option
       | optop of bool
       | optty of Absyn.ty option
       | patseq_comma of Absyn.pat list
       | patlongid of Absyn.longsymbol
       | patlongsymbol of Symbol.longsymbol
       | pat of Absyn.pat
       | start of Absyn.unitparseresult
       | strexpbasic of Absyn.strexp
       | strexp of Absyn.strexp
       | strexpcomb of Absyn.strexp
       | strexpandexp of Absyn.strexp
       | strexpand of Absyn.strexp
       | strdec of Absyn.strdec
       | strdecseq_semicolon of Absyn.strdec list
       | strbind of Absyn.strbind
       | strbindand of Absyn.strbind
       | sigbind of (Symbol.symbol * Absyn.sigexp) list
       | spec of Absyn.spec
       | strdesc of (Symbol.symbol * Absyn.sigexp) list
       | strbindseq of Absyn.strbind list
       | sigidseq of Symbol.symbol list
       | sharespec of Symbol.longsymbol list
       | sigexpbasic of Absyn.sigexp
       | sigexpwhere of Absyn.sigexp
       | sigexp of Absyn.sigexp
       | sigexpand of Absyn.sigexp
       | ty of Absyn.ty
       | ty0 of Absyn.ty
       | ty1 of Absyn.ty
       | tycon of Symbol.symbol
       | tyseq_comma of Absyn.ty list
       | tyseq of Absyn.ty list
       | tyrow of (string * Absyn.ty) list
       | tytuple of Absyn.ty list
       | tyvar of Absyn.tvar
       | tyvarseq of Absyn.tvar list
       | tyvarseq_comma of Absyn.tvar list

(* poly ty stuff 
  Ohori: poly_ty, poly_ty1, poly_tyrow, poly_tytuple  are added
  for rank1 type specification.
  2007/11/11
  Need to extend with other kinds
*)
       | poly_ty of Absyn.ty
       | poly_ty1 of Absyn.ty
       | poly_tyrow of (string * Absyn.ty) list
       | poly_tytuple of Absyn.ty list
       | kinded_tyvar of Absyn.tvar * Absyn.tvarKind
       | kinded_tyvarseq of (Absyn.tvar * Absyn.tvarKind) list
       | kinded_tyvarseq_without_paren of (Absyn.tvar * Absyn.tvarKind) list
       | kinded_tyvarseq_comma of (Absyn.tvar * Absyn.tvarKind) list
(* end of poly ty stuff *)

       | ffiApplyArg of Absyn.ffiArg
       | ffiApplyArgs of Absyn.ffiArg list
       | ffiApplyArgSeq of Absyn.ffiArg list
       | ffityrow of (string * Absyn.ffiTy) list
       | ffityseq of Absyn.ffiTy list
       | ffiVarArgs of Absyn.ffiTy list
       | ffiArgs of Absyn.ffiTy list * Absyn.ffiTy list option
       | ffiContyArg of Absyn.ffiTy list
       | ffiAtty of Absyn.ffiTy
       | ffitupleseq of Absyn.ffiTy list
       | ffiTupleTy of Absyn.ffiTy
       | ffiFunArg of Absyn.ffiTy list * Absyn.ffiTy list option
       | ffiFunRet of Absyn.ffiTy list
       | ffiFunty of Absyn.ffiTy
       | ffiattrseq of string list
       | ffiattr of string list
       | ffiattropt of string list
       | ffity of Absyn.ffiTy
(*
       | old_ffiContyArg of Absyn.ty list
       | old_ffiAtty of Absyn.ty
       | old_ffituple of Absyn.ty list
       | old_ffityseq of Absyn.ty list
       | old_ffityArg of Absyn.ty list
       | old_ffiFunty of Absyn.ty list * Absyn.ty
       | old_ffity of Absyn.ty
*)
       | typbind of
         {
           tyvars : Absyn.tvar list,
           tyConSymbol : Symbol.symbol,
           ty : Absyn.ty,
           formatComments : Absyn.definingFormatComment list
         } list
       | typdesc of (Absyn.tvar list * Symbol.symbol) list
       | useFile of Absyn.top
       | tops of Absyn.top list
       | topdecs of Absyn.topdec list
       | topdec of Absyn.topdec
       | interface of Absyn.interface
       | unit of Absyn.unit
       | valdesc of (Symbol.symbol * Absyn.ty) list
       | valbind of (Absyn.pat * Absyn.exp) list

(* polymorphic recursion *)
       | pvalbind of (Symbol.symbol * Absyn.ty * Absyn.exp) list

       | sql of Absyn.exp AbsynSQL.command
       | sqlExp of Absyn.exp
       | sqlExpAsList of string list * Absyn.exp list
       | sqlExpList of Absyn.exp list
       | sqlExpOrDefault of Absyn.exp option
       | sqlExpOrDefaultList of Absyn.exp option list
       | sqlLabelList of string list
       | sqlInsertRowList of Absyn.exp option list list
       | selectList of string list option * Absyn.exp list
       | asNameOpt of string option 
       | intoClause of Symbol.symbol option 
       | fromClause of (string * Absyn.exp) list
       | whereClause of Absyn.exp option
       | orderbyClause of {keyExp: Absyn.exp, orderAsc: bool} list
       | orderbyList of {keyExp: Absyn.exp, orderAsc: bool} list
       | sqlorder of bool
       | setClause of string list * Absyn.exp list
       | sqlserver of (string * Absyn.exp) list

       (* SMLFormat extension *)
       | selector of string
       | header_format_comment_list of Absyn.headerFormatComment list
       | header_format_specs of Absyn.headerFormatComment
       | ditto_spec of string
       | prefix_spec of string
       | prefix_spec_opt of string
       | destination_spec of string
       | funheader_spec of string
       | formatter_spec of Symbol.longsymbol * Symbol.longsymbol
       | formatparams_spec of Symbol.symbol list
       | formatparam_list of Symbol.symbol list
       | defining_format_comment of Absyn.definingFormatComment
       | defining_format_comment_list of Absyn.definingFormatComment list
       | formattag of FormatTemplate.formattag
       | localformattags of FormatTemplate.formattag list
       | localformattag of FormatTemplate.formattag
       | typepat of FormatTemplate.typepat
       | typepat' of FormatTemplate.typepat
       | tuple_typepat of FormatTemplate.typepat list
       | typepat_rows of (string * FormatTemplate.typepat) list * bool
       | typepat_field of string * FormatTemplate.typepat
       | atypepat of FormatTemplate.typepat
       | atypepat_list of FormatTemplate.typepat list
       | templates of FormatTemplate.template list
       | template of FormatTemplate.template
       | inst of FormatTemplate.instance
       | opt_typed of Symbol.symbol option
       | insts of FormatTemplate.instance list
       | templates_comma_list of FormatTemplate.template list list

       | noReduce1 of unit

%name ML
%header (
structure MLLrVals
)
%footer ()
%right ARROW
%right AND
%right DARROW 
%nonassoc BAR
%left DO
%left ELSE
%left RAISE
%right HANDLE
%left ORELSE
%left ANDALSO
%right AS
%left COLON
%noshift EOF
%verbose
%start start
%%

start : unit (Absyn.UNIT unit)
      | expOrSQL (Absyn.UNIT
                  {
                   tops=
                    [Absyn.TOPDEC
                       [Absyn.TOPDECSTR
                          (Absyn.COREDEC
                             (Absyn.DECVAL
                                  (nil,
                                   [
                                    (Absyn.PATID {opPrefix=false,
                                                  longsymbol=Symbol.mkLongsymbol ["it"] (Loc.nopos,Loc.nopos),
                                                  loc=(Loc.nopos,Loc.nopos)}, 
                                     expOrSQL)
                                    ],
                                   (expOrSQLleft,expOrSQLright)),
                                  (Loc.nopos,Loc.nopos)),
                             (Loc.nopos,Loc.nopos))
                        ]
                    ],
                   interface = Absyn.NOINTERFACE,
                   loc = (Loc.nopos,Loc.nopos)
                  }
            )

(****************** constant ***************************)
int      : INT (INT)
         | INTLAB ({radix=StringCvt.DEC, digits=INTLAB})

constant : int (Absyn.INT(int,(intleft,intright)))
         | WORD (Absyn.WORD(WORD,(WORDleft,WORDright)))
         | STRING (Absyn.STRING(STRING,(STRINGleft,STRINGright)))
         | REAL (Absyn.REAL(REAL,(REALleft,REALright)))
         | CHAR (Absyn.CHAR(String.sub(CHAR, 0),(CHARleft,CHARright)))
         | NULL (Absyn.NULLCONST(NULLleft,NULLright))
(* end of constant *)

(*** raw id ***)

id_noEQSTAR : ID (Symbol.mkSymbol ID (IDleft, IDright))
            | SELECT (Symbol.mkSymbol "select" (SELECTleft, SELECTright))
            | FROM (Symbol.mkSymbol "from" (FROMleft, FROMright))
            | ORDER (Symbol.mkSymbol "order" (ORDERleft, ORDERright))
            | BY (Symbol.mkSymbol "by" (BYleft, BYright))
            | INSERT (Symbol.mkSymbol "insert" (INSERTleft, INSERTright))
            | INTO (Symbol.mkSymbol "into" (INTOleft, INTOright))
            | VALUES (Symbol.mkSymbol "values" (VALUESleft, VALUESright))
            | DELETE (Symbol.mkSymbol "delete" (DELETEleft, DELETEright))
            | ASC (Symbol.mkSymbol "asc" (ASCleft, ASCright))
            | DESC (Symbol.mkSymbol "desc" (DESCleft, DESCright))
            | UPDATE (Symbol.mkSymbol "update" (UPDATEleft, UPDATEright))
            | SET (Symbol.mkSymbol "set" (SETleft, SETright))
            | DEFAULT (Symbol.mkSymbol "default" (DEFAULTleft, DEFAULTright))
            | BEGIN (Symbol.mkSymbol "begin" (BEGINleft, BEGINright))
            | COMMIT (Symbol.mkSymbol "commit" (COMMITleft, COMMITright))
            | ROLLBACK (Symbol.mkSymbol "rollback" (ROLLBACKleft, ROLLBACKright))

id_noEQ     : id_noEQSTAR (id_noEQSTAR)
            | ASTERISK (Symbol.mkSymbol "*" (ASTERISKleft, ASTERISKright))

id          : id_noEQ (id_noEQ)
            | EQ (Symbol.mkSymbol "=" (EQleft,EQright))

id_noSQL    : ID (Symbol.mkSymbol ID (IDleft, IDright))
            | ASTERISK (Symbol.mkSymbol "*" (ASTERISKleft, ASTERISKright))
            | EQ (Symbol.mkSymbol "=" (EQleft,EQright))

longid : id ([id])
       | id PERIOD longid (id::longid)

(*
longtyconid : id ([id])
            | id PERIOD longtyconid (id::longtyconid)
*)

longid_noSQL : id_noSQL ([id_noSQL])
            | id_noSQL PERIOD longid (id_noSQL::longid)

tylongid : id_noEQSTAR ([id_noEQSTAR])
         | id_noEQSTAR PERIOD longid (id_noEQSTAR :: longid)

patlongid : id_noEQ ([id_noEQ])
          | id_noEQ PERIOD longid (id_noEQ :: longid)
   

(*** symbols

 expid : longid (longid)

 symbol_noEQSTAR     : id_noEQSTAR (Symbol.mkSymbol id_noEQSTAR (id_noEQSTARleft, id_noEQSTARright))
 symbol              : id (Symbol.mkSymbol id (idleft,idright))
 longsymbol          : longid (Symbol.mkLongsymbol longid (longidleft,longidright))
 longtycon           : longtyconid (Symbol.mkLongsymbol longtyconid (longtyconidleft,longtyconidright))
 explongsymbol       : expid (Symbol.mkLongsymbol expid (expidleft,expidright))
 explongsymbol_noSQL : expid_noSQL (Symbol.mkLongsymbol expid_noSQL (expid_noSQLleft,expid_noSQLright))
 tylongsymbol        : tylongid (Symbol.mkLongsymbol tylongid (tylongidleft,tylongidright))
 patlongsymbol       : patlongid (Symbol.mkLongsymbol patlongid (patlongidleft,patlongidright))

 symbolseq : symbol ([symbol])
           | symbol symbolseq (symbol::symbolseq)

 longsymbolseq : longsymbol ([longsymbol])
           | longsymbol longsymbolseq (longsymbol::longsymbolseq)

***)

idseq : id ([id])
          | id idseq (id::idseq)

longidseq : longid ([longid])
          | longid longidseq (longid::longidseq)

(*** expressions ***)

atexp_noVAR
      : constant (Absyn.EXPCONSTANT constant)
      | JOIN LPAREN exp COMMA exp RPAREN (Absyn.EXPJOIN(exp1, exp2, (JOINleft, RPARENright)))
      | OP longid (Absyn.EXPOPID(longid,(OPleft,longidright)))
      | LBRACE exprow RBRACE (Absyn.EXPRECORD(exprow,(LBRACEleft,RBRACEright)))
      | LBRACE RBRACE (Absyn.EXPCONSTANT(Absyn.UNITCONST(LBRACEleft,RBRACEright)))
      | HASH id (Absyn.EXPRECORD_SELECTOR(id,(HASHleft,idright)))
      | HASH INTLAB
        (Absyn.EXPRECORD_SELECTOR(Symbol.mkSymbol INTLAB (INTLABleft,INTLABright),(HASHleft,INTLABright)))
      | LPAREN RPAREN (Absyn.EXPCONSTANT(Absyn.UNITCONST(LPARENleft,RPARENright)))
      | LPAREN expseq_comma RPAREN
                (Absyn.EXPTUPLE(expseq_comma,(LPARENleft,RPARENright)))
      | LBRACKET RBRACKET (Absyn.EXPLIST([],(LBRACKETleft,RBRACKETright)))
      | LBRACKET exp RBRACKET
                (Absyn.EXPLIST([exp],(LBRACKETleft,RBRACKETright)))
      | LBRACKET expseq_comma RBRACKET
                (Absyn.EXPLIST(expseq_comma,(LBRACKETleft,RBRACKETright)))
      | LPAREN exp SEMICOLON expseq_semicolon RPAREN
        (Absyn.EXPSEQ(exp :: expseq_semicolon,(LPARENleft,RPARENright)))
      | LET decseq_semicolon IN expseq_semicolon END
        (Absyn.EXPLET(decseq_semicolon,expseq_semicolon,(LETleft,ENDright)))
      | LPAREN expOrSQL RPAREN
        (Absyn.replaceLoc(expOrSQL,(LPARENleft,RPARENright)))
      | HASH id PERIOD label
        (Absyn.EXPSQL
          (AbsynSQL.SQLFIELDSELECT
             (label, Absyn.EXPID (Symbol.mkLongsymbol  [Symbol.symbolToString id] (idleft, idright)),
              (HASHleft, labelright)),
           (HASHleft, labelright)))
(*
      | SQLTABLE label
          (Absyn.EXPSQLTABLE(label,(SQLTABLEleft,labelright)))
      | SQLCOLUMN label OF label
          (Absyn.EXPSQLCOLUMN(label1,label2,(SQLCOLUMNleft,label2right)))
      | HASH label PERIOD label
          (Absyn.EXPSQLCOLUMN(label2,label1,(HASHleft,label2right)))
*)

atexp : atexp_noVAR (atexp_noVAR)
      | longid (Absyn.EXPID(longid))

atexp_noSQL : atexp_noVAR (atexp_noVAR)
            | longid_noSQL
                (Absyn.EXPID(longid_noSQL))

label : id (Symbol.symbolToString id)
      | INTLAB (INTLAB)

(* equal or more than 1 *)
exprow : label EQ exp ([(label,exp)])
       | exprow COMMA label EQ exp (exprow @ [(label,exp)])

(* equal or more than 2 exps *)
expseq_comma : exp COMMA exp ([exp1,exp2])
             | expseq_comma COMMA exp (expseq_comma @ [exp])

(* equal or more than 1 exps *)
expseq_semicolon : expOrSQL ([expOrSQL])
        | expseq_semicolon SEMICOLON expOrSQL (expseq_semicolon @ [expOrSQL])

appexp : atexp (Absyn.EXPAPP([atexp],(atexpleft,atexpright)))
       | appexp atexp
                (case appexp of
                   Absyn.EXPAPP(l,_) =>
                   Absyn.EXPAPP(l@[atexp],(appexpleft,atexpright))
                 | _ => Absyn.EXPAPP([appexp,atexp],(appexpleft,atexpright)))
       | appexp HASH LBRACE exprow RBRACE
         (Absyn.EXPRECORD_UPDATE(appexp,exprow,(appexpleft,RBRACEright)))
       | appexp HASH LPAREN expseq_comma RPAREN
         (Absyn.EXPRECORD_UPDATE
            (appexp,
             #2 (foldr (fn (exp, (n, exprow)) =>
                           (n - 1, (Int.toString n, exp)::exprow))
                       (length expseq_comma, nil) expseq_comma),
             (appexpleft, RPARENright)))
       | SQLEXEC atexp
         (Absyn.EXPSQL
            (AbsynSQL.SQLEXEC
               (Absyn.EXPAPP ([atexp], (atexpleft, atexpright)),
                (SQLEXECleft, atexpright)),
             (SQLEXECleft, atexpright)))
       | SQLEVAL atexp
         (Absyn.EXPSQL
            (AbsynSQL.SQLEVAL
               (Absyn.EXPAPP ([atexp], (atexpleft, atexpright)),
                (SQLEVALleft, atexpright)),
             (SQLEVALleft, atexpright)))

appexp_noSQL : atexp_noSQL
                 (Absyn.EXPAPP([atexp_noSQL],
                               (atexp_noSQLleft, atexp_noSQLright)))
             | appexp_noSQL atexp_noSQL
                 (let val loc = (appexp_noSQLleft, atexp_noSQLright)
                  in case appexp_noSQL of
                       Absyn.EXPAPP(l,_) => Absyn.EXPAPP(l@[atexp_noSQL], loc)
                     | _ => Absyn.EXPAPP([appexp_noSQL,atexp_noSQL], loc)
                  end)
             | SQLEXEC atexp_noSQL
               (Absyn.EXPSQL
                  (AbsynSQL.SQLEXEC
                     (Absyn.EXPAPP
                        ([atexp_noSQL],
                         (atexp_noSQLleft, atexp_noSQLright)),
                      (SQLEXECleft, atexp_noSQLright)),
                   (SQLEXECleft, atexp_noSQLright)))
             | SQLEVAL atexp_noSQL
               (Absyn.EXPSQL
                  (AbsynSQL.SQLEVAL
                     (Absyn.EXPAPP
                        ([atexp_noSQL],
                         (atexp_noSQLleft, atexp_noSQLright)),
                      (SQLEVALleft, atexp_noSQLright)),
                   (SQLEVALleft, atexp_noSQLright)))

exp : appexp (appexp)
    | exp COLON ty (Absyn.EXPTYPED(exp,ty,(expleft,tyright)))
    | exp COLON IMPORT ffity
          (Absyn.EXPFFIIMPORT(Absyn.FFIFUN exp,ffity,(expleft,ffityright)))
    | IMPORT STRING COLON ffity
          (Absyn.EXPFFIIMPORT
             (Absyn.FFIEXTERN STRING, ffity, (IMPORTleft,ffityright)))
    | FFIAPPLY ffiattropt atexp LPAREN ffiApplyArgs RPAREN COLON ffiFunRet
          (Absyn.EXPFFIAPPLY(ffiattropt, Absyn.FFIFUN atexp, ffiApplyArgs,
                             ffiFunRet, (FFIAPPLYleft,ffiFunRetright)))
    | FFIAPPLY ffiattropt IMPORT STRING LPAREN ffiApplyArgs RPAREN COLON ffiFunRet
          (Absyn.EXPFFIAPPLY
             (ffiattropt, Absyn.FFIEXTERN STRING, ffiApplyArgs, ffiFunRet,
              (FFIAPPLYleft,ffiFunRetright)))
    | exp ANDALSO exp (Absyn.EXPCONJUNCTION(exp1,exp2,(exp1left,exp2right)))
    | exp ORELSE exp (Absyn.EXPDISJUNCTION(exp1,exp2,(exp1left,exp2right)))
    | exp HANDLE match (Absyn.EXPHANDLE(exp,match,(expleft,matchright)))
    | RAISE exp (Absyn.EXPRAISE(exp,(RAISEleft,expright)))
    | IF exp THEN exp ELSE exp (Absyn.EXPIF(exp1,exp2,exp3,(IFleft,exp3right)))
    | WHILE exp DO exp (Absyn.EXPWHILE(exp1,exp2,(WHILEleft,exp2right)))
    | CASE exp OF match (Absyn.EXPCASE(exp,match,(CASEleft,matchright)))
    | FN match (Absyn.EXPFN(match,(FNleft,matchright)))
    | SQLSERVER COLON ty
        (Absyn.EXPSQL
           (AbsynSQL.SQLSERVER
              (Absyn.EXPCONSTANT(Absyn.STRING("",(COLONleft,COLONleft))),
               ty,(SQLSERVERleft,tyright)),
            (SQLSERVERleft,tyright)))
    | SQLSERVER appexp COLON ty
        (Absyn.EXPSQL
           (AbsynSQL.SQLSERVER(appexp,ty,(SQLSERVERleft,tyright)),
            (SQLSERVERleft,tyright)))

expOrSQL : exp (exp)
         | SQL pat DARROW sql
             (Absyn.EXPSQL
                (AbsynSQL.SQLFN (pat, sql, (SQLleft, sqlright)),
                 (SQLleft, sqlright)))

(*
match : mrule                        ([mrule])
      | mrule BAR match                (mrule::match)
mrule : pat DARROW exp                ((pat,exp))

match : mrule                        ([mrule])
      | mrulebar match                (mrulebar::match)
mrule : pat DARROW exp                ((pat,exp))
mrulebar : pat DARROW exp BAR                ((pat,exp))

It seems that the core ML's "|" has inherent problem, which coincides
with my experience. I have been bothered by the "|" in combination
with  case, fn, and  handle.
*)

match : pat DARROW exp                ([(pat,exp)])
      | pat DARROW exp BAR match ((pat,exp)::match)

(* end of expression *)

(*************************** sql ********************************)

sql : SELECT selectList intoClause fromClause whereClause orderbyClause
        (AbsynSQL.SQLSELECT {selectListExps = #2 selectList,
                             selectLabels = #1 selectList,
                             selectName = intoClause,
                             fromClause = fromClause,
                             whereClause = whereClause,
                             orderByClause = orderbyClause,
                             loc = (SELECTleft, orderbyClauseright)})
    | INSERT INTO HASH id PERIOD label LPAREN sqlLabelList RPAREN
      VALUES sqlInsertRowList
        (AbsynSQL.SQLINSERT {table = (id, label),
                             insertRows = sqlInsertRowList,
                             insertLabels = sqlLabelList,
                             loc = (INSERTleft, sqlInsertRowListright)})
    | DELETE FROM HASH id PERIOD label asNameOpt whereClause
        (AbsynSQL.SQLDELETE {table = (id, label),
                             tableName = asNameOpt,
                             whereClause = whereClause,
                             loc = (DELETEleft, whereClauseright)})
    | UPDATE HASH id PERIOD label asNameOpt setClause fromClause whereClause
        (AbsynSQL.SQLUPDATE {table = (id, label),
                             tableName = asNameOpt,
                             setListExps = #2 setClause,
                             setLabels = #1 setClause,
                             fromClause = fromClause,
                             whereClause = whereClause,
                             loc = (UPDATEleft, whereClauseright)})
    | BEGIN
        (AbsynSQL.SQLBEGIN (BEGINleft, BEGINright))
    | COMMIT
        (AbsynSQL.SQLCOMMIT (COMMITleft, COMMITright))
    | ROLLBACK
        (AbsynSQL.SQLROLLBACK (ROLLBACKleft, ROLLBACKright))

sqlExp : appexp_noSQL (appexp_noSQL)
(*       | sqlExp COLON ty ()*)
       | sqlExp ANDALSO sqlExp
           (Absyn.EXPCONJUNCTION(sqlExp1,sqlExp2,(sqlExp1left,sqlExp2right)))
       | sqlExp ORELSE sqlExp
           (Absyn.EXPDISJUNCTION(sqlExp1,sqlExp2,(sqlExp1left,sqlExp2right)))

asNameOpt : (* none *) (NONE)
          | AS label (SOME label)

intoClause : (* none *) (NONE)
           | INTO id (SOME id)

sqlExpAsList : sqlExp AS label (([label], [sqlExp]))
             | sqlExp AS label COMMA sqlExpAsList
                 ((label :: #1 sqlExpAsList, sqlExp :: #2 sqlExpAsList))

sqlExpList : sqlExp ([sqlExp])
           | sqlExp COMMA sqlExpList (sqlExp::sqlExpList)

sqlExpOrDefault : sqlExp (SOME sqlExp)
                | DEFAULT (NONE)

sqlExpOrDefaultList : sqlExpOrDefault ([sqlExpOrDefault])
                    | sqlExpOrDefault COMMA sqlExpOrDefaultList
                        (sqlExpOrDefault::sqlExpOrDefaultList)

sqlLabelList : label ([label])
             | label COMMA sqlLabelList (label::sqlLabelList)

sqlInsertRowList : LPAREN sqlExpOrDefaultList RPAREN ([sqlExpOrDefaultList])
                 | LPAREN sqlExpOrDefaultList RPAREN COMMA sqlInsertRowList
                     (sqlExpOrDefaultList :: sqlInsertRowList)

selectList : sqlExpAsList ((SOME (#1 sqlExpAsList), #2 sqlExpAsList))
           | sqlExpList ((NONE, sqlExpList))
(*           | LPAREN sqlExpAsList RPAREN (sqlExpAsList)*)
(*           | LBRACE exprow RBRACE (exprow)*)

fromClause : (* none *) ([])
           | FROM sqlExpAsList (ListPair.zip sqlExpAsList)

whereClause : (* none *) (NONE)
            | WHERE sqlExp (SOME sqlExp)

orderbyClause : (* none *) ([])
              | ORDER BY orderbyList (orderbyList)

orderbyList : sqlExp sqlorder
                ([{keyExp=sqlExp, orderAsc=sqlorder}])
            | sqlExp sqlorder COMMA orderbyList
                ({keyExp=sqlExp, orderAsc=sqlorder} :: orderbyList)

sqlorder : (* none *)  (true)
         | ASC         (false)
         | DESC        (false)

setClause : SET label EQ sqlExp
              (([label], [sqlExp]))
          | SET LPAREN sqlLabelList RPAREN EQ LPAREN sqlExpList RPAREN
              ((sqlLabelList, sqlExpList))

(*************************** dec ********************************)
(*decs : dec      ([dec])
     | dec decs (dec::decs)*)
decseq_semicolon : ([])
                 | SEMICOLON decseq_semicolon (decseq_semicolon)
                 | dec decseq_semicolon (dec::decseq_semicolon)
                 | LOCAL decseq_semicolon IN decseq_semicolon END
                   decseq_semicolon 
                (Absyn.DECLOCAL
                  (decseq_semicolon1,decseq_semicolon2,(LOCALleft,ENDright))
                 :: decseq_semicolon3) 

(*
  Ohori: VAL, VAL REC and FUN now take kinded_tyvarseq
  instead of tyvar_seq.
  2007/11/11
*)

(* 160 *)

dec : VAL valbind (Absyn.DECVAL(nil,valbind,(VALleft,valbindright)))
    | VAL kinded_tyvarseq valbind
                (Absyn.DECVAL(kinded_tyvarseq,valbind,(VALleft,valbindright)))
    | VAL REC valbind (Absyn.DECREC(nil,valbind,(VALleft,valbindright)))
    | VAL REC kinded_tyvarseq valbind
                (Absyn.DECREC(kinded_tyvarseq,valbind,(VALleft,valbindright)))
(* polymorphic recursion *)
    | VAL POLYREC pvalbind (Absyn.DECPOLYREC(pvalbind,(VALleft,pvalbindright)))
    | FUN fvalbind (Absyn.DECFUN(nil,fvalbind,(FUNleft,fvalbindright)))
    | FUN kinded_tyvarseq fvalbind
                (Absyn.DECFUN(kinded_tyvarseq,fvalbind,(FUNleft,fvalbindright)))
    | header_format_comment_list TYPE typbind
                (Absyn.DECTYPE {formatComments=header_format_comment_list,
                                tbs=typbind,
                                loc=(TYPEleft,typbindright)
                               })
    | header_format_comment_list DATATYPE datbind
                (Absyn.DECDATATYPE
                   {formatComments=header_format_comment_list,
                    datatys=datbind,
                    withtys=[],
                    loc=(DATATYPEleft,datbindright)}
                )
    | header_format_comment_list DATATYPE datbind WITHTYPE typbind
                (Absyn.DECDATATYPE
                   {formatComments=header_format_comment_list,
                    datatys=datbind,
                    withtys=typbind,
                    loc=(DATATYPEleft,typbindright)}
                )
    | header_format_comment_list DATATYPE tycon EQ DATATYPE longid
                (Absyn.DECREPLICATEDAT
                   {formatComments = header_format_comment_list,
                    defSymbol=tycon,
                    refLongsymbol = longid,
                    loc=(DATATYPEleft,longidright)})
    | header_format_comment_list ABSTYPE datbind WITH decseq_semicolon END
      (Absyn.DECABSTYPE
           {formatComments=header_format_comment_list,
            abstys=datbind, 
            withtys=[], 
            body=decseq_semicolon, 
            loc=(ABSTYPEleft, ENDright)})
    | header_format_comment_list ABSTYPE datbind WITHTYPE typbind WITH decseq_semicolon END
      (Absyn.DECABSTYPE
           {formatComments=header_format_comment_list,
            abstys=datbind, 
            withtys=typbind,
            body=decseq_semicolon, 
            loc=(ABSTYPEleft, ENDright)})
    | header_format_comment_list EXCEPTION exbinds 
                (Absyn.DECEXN
                   {formatComments=header_format_comment_list,
                    exbinds=exbinds,
                    loc=(EXCEPTIONleft,exbindsright)})
(*    
    | LOCAL decseq_semicolon IN decseq_semicolon END                
      (Absyn.LOCALDEC(decseq_semicolon1,decseq_semicolon2,(LOCALleft,ENDright)))
*)
    | OPEN longidseq (Absyn.DECOPEN(longidseq,(OPENleft,longidseqright)))
    | INFIX int idseq
                (Absyn.DECINFIX(#digits int,
                                idseq,(INFIXleft,idseqright)))
    | INFIXR int idseq
          (Absyn.DECINFIXR(#digits int,
                           idseq,(INFIXRleft,idseqright)))
(*  infix/infixr without number is added. 2004.3.21. Ohori *)
    | INFIX idseq (Absyn.DECINFIX("0",idseq,(INFIXleft,idseqright)))
    | INFIXR idseq (Absyn.DECINFIXR("0",idseq,(INFIXRleft,idseqright)))
    | NONFIX idseq (Absyn.DECNONFIX(idseq,(NONFIXleft,idseqright)))
(*
(*  deprecated syntax  *)
    | VAL EXTERNAL ffiattropt id EQ appexp COLON old_ffiFunty
        (Absyn.DECVAL(nil,
           [(Absyn.PATID({opPrefix=false,id=[id],loc=(idleft,idright)}),
             Absyn.EXPFFIIMPORT
               (appexp,
                Absyn.TYFFI(Absyn.defaultFFIAttributes,
                            ffiattropt,
                            #1 old_ffiFunty,
                            #2 old_ffiFunty,
                            (old_ffiFuntyleft,old_ffiFuntyright)),
                (appexpleft,old_ffiFuntyright)))],
                      (VALleft,old_ffiFuntyright)))
*)

(*
 In this version, we ignore kind constraint in type bind.
   type ('a, 'b#{a:'a}) foo = 'b -> 'a
 is interpreted as
   type ('a, 'b) foo = 'b -> 'a
*)
typbind : tycon EQ defining_format_comment_list ty 
                ([
                 {tyvars=nil,
                  tyConSymbol=tycon,
                  ty=ty,
                  formatComments = defining_format_comment_list
                 }
                ])
        | tyvarseq tycon EQ defining_format_comment_list ty 
                ([
                 {tyvars=tyvarseq,
                  tyConSymbol=tycon,
                  ty=ty,
                  formatComments = defining_format_comment_list
                 }
                ])
        | tycon EQ defining_format_comment_list ty AND typbind 
                (
                 {tyvars=nil,
                  tyConSymbol=tycon,
                  ty=ty,
                  formatComments = defining_format_comment_list
                 }
                 ::typbind
                )
        | tyvarseq tycon EQ defining_format_comment_list ty AND typbind
                (
                 {tyvars=tyvarseq,
                  tyConSymbol=tycon,
                  ty=ty,
                  formatComments = defining_format_comment_list
                 }
                 ::typbind)

datbind : tycon EQ combind 
                ([
                 {
                  tyvars=nil,
                  tyConSymbol=tycon,
                  rhs=combind
                 }])
        | tyvarseq tycon EQ combind 
                ([
                 {
                  tyvars=tyvarseq,
                  tyConSymbol=tycon,
                  rhs=combind
                 }
                ])
        | tycon EQ combind AND datbind
                (
                 {
                  tyvars=nil,
                  tyConSymbol=tycon,
                  rhs=combind
                 }
                 ::datbind
                )
        | tyvarseq tycon EQ combind AND datbind
                (
                 {
                  tyvars=tyvarseq,
                  tyConSymbol=tycon,
                  rhs=combind
                 }
                 ::datbind)

combind : condec ([condec])
        | condec BAR combind (condec::combind)

condec : defining_format_comment_list tycon 
         (
          {opFlag=false,
           conSymbol=tycon,
           tyOpt=NONE,
           formatComments=defining_format_comment_list
           }
         )
       | defining_format_comment_list OP tycon 
         (
          {opFlag=true,
           conSymbol=tycon,
           tyOpt=NONE,
           formatComments=defining_format_comment_list
           }
         )
       | defining_format_comment_list tycon OF ty 
         (
          {opFlag=false,
           conSymbol=tycon,
           tyOpt=SOME ty,
           formatComments=defining_format_comment_list
           }
         )
       | defining_format_comment_list OP tycon OF ty 
         (
          {opFlag=true,
           conSymbol=tycon,
           tyOpt=SOME ty,
           formatComments=defining_format_comment_list
           }
         )

exbinds : exbind ([exbind])
        | exbind AND exbinds (exbind :: exbinds)

exbind : defining_format_comment_list exndec
         (let val (isOp, name, tyOpt) = exndec
          in Absyn.EXBINDDEF
               {opFlag=isOp, 
                conSymbol=name, 
                tyOpt=tyOpt, 
                formatComments=defining_format_comment_list,
                loc=(exndecleft, exndecright)
               }
          end)
       | defining_format_comment_list id EQ longid
         (Absyn.EXBINDREP
            {
             opFlag1=false,
             conSymbol=id, 
             refLongsymbol=longid,
             opFlag2=false,
             loc=(idleft,longidright),
             formatComments=defining_format_comment_list
            }
         )
       | defining_format_comment_list id EQ OP longid
         (Absyn.EXBINDREP
            {
             opFlag1=false,
             conSymbol=id, 
             opFlag2=true,
             refLongsymbol=longid,
             loc=(idleft,longidright),
             formatComments=defining_format_comment_list
            }
         )
       | defining_format_comment_list OP id EQ longid
         (Absyn.EXBINDREP
            {
             opFlag1=true,
             conSymbol=id, 
             opFlag2=false,
             refLongsymbol=longid,
             loc=(idleft,longidright),
             formatComments=defining_format_comment_list
            }
         )
       | defining_format_comment_list OP id EQ OP longid
         (Absyn.EXBINDREP
            {
             opFlag1=true,
             conSymbol=id,
             opFlag2=true,
             refLongsymbol=longid,
             loc=(idleft,longidright),
             formatComments=defining_format_comment_list
            }
         )

exndec : tycon ((false,tycon,NONE))
       | OP tycon ((true,tycon,NONE))
       | tycon OF ty ((false,tycon,SOME ty))
       | OP tycon OF ty ((true,tycon,SOME ty))

(* 200 *)

tyvar : TYVAR ({symbol=Symbol.mkSymbol TYVAR (TYVARleft,TYVARright),
                eq=Absyn.NONEQ})
      | EQTYVAR ({symbol=Symbol.mkSymbol EQTYVAR (EQTYVARleft,EQTYVARright),
                  eq=Absyn.EQ})

tyvarseq : tyvar ([tyvar])
         | LPAREN tyvar RPAREN ([tyvar])
         | LPAREN tyvarseq_comma RPAREN (tyvarseq_comma)

tyvarseq_comma : tyvar COMMA tyvar ([tyvar1,tyvar2])
               | tyvar COMMA tyvarseq_comma (tyvar::tyvarseq_comma)


valbind : pat EQ expOrSQL ([(pat,expOrSQL)])
        | pat EQ expOrSQL AND valbind  ((pat,expOrSQL)::valbind)

pvalbind : id COLON poly_ty EQ expOrSQL ([(id, poly_ty, expOrSQL)])
         | id COLON poly_ty EQ expOrSQL AND pvalbind ((id, poly_ty, expOrSQL)::pvalbind)

fvalbind : frules ([{fdecl=frules, loc=(frulesleft, frulesright)}])
         | frules AND fvalbind ({fdecl=frules, loc=(frulesleft, frulesright)} :: fvalbind)

frules : frule ([frule])
      | frule BAR frules (frule::frules)

frule : apppat EQ expOrSQL (apppat, NONE, expOrSQL)
      | apppat COLON ty EQ expOrSQL (apppat, SOME ty, expOrSQL)

(*****************  pattern ***********************)
atpat : UNDERBAR (Absyn.PATWILD((UNDERBARleft,UNDERBARright)))
      | patlongid
          (Absyn.PATID({opPrefix=false,longsymbol=patlongid,loc=(patlongidleft,patlongidright)}))
      | OP patlongid
          (Absyn.PATID({opPrefix=true, longsymbol=patlongid, loc=(patlongidleft,patlongidright)}))
      | constant (Absyn.PATCONSTANT constant)
      | LBRACE RBRACE
          (Absyn.PATCONSTANT
            (Absyn.UNITCONST(LBRACEleft,RBRACEright)))
      | LBRACE fields RBRACE
          (Absyn.PATRECORD
            ({
               ifFlex = #1 fields,
               fields = #2 fields,
               loc = (LBRACEleft,RBRACEright)
             }))
      | LPAREN RPAREN
          (Absyn.PATCONSTANT
            (Absyn.UNITCONST(LPARENleft,RPARENright)))
      | LPAREN patseq_comma RPAREN
                (Absyn.PATTUPLE(patseq_comma,(LPARENleft,RPARENright)))
      | LBRACKET RBRACKET (Absyn.PATLIST([],(LBRACKETleft,RBRACKETright)))
      | LBRACKET pat RBRACKET
                (Absyn.PATLIST([pat],(LBRACKETleft,RBRACKETright)))
      | LBRACKET patseq_comma RBRACKET
                (Absyn.PATLIST(patseq_comma,(LBRACKETleft,RBRACKETright)))
      | LPAREN pat RPAREN (pat)

apppat : atpat ([atpat])
       | apppat atpat (apppat@[atpat])

pat : apppat (Absyn.PATAPPLY(apppat,(apppatleft,apppatright)))
                (* Even if apppat has only single pattern, it is encupslated
                 * into a PATAPPLY, in order to check invalid use of infix
                 * identifier in the elaboration phase. *)
    | pat COLON ty (Absyn.PATTYPED(pat,ty,(patleft,tyright)))
    | pat AS pat (Absyn.PATLAYERED(pat1,pat2,(pat1left,pat2right)))

optty : COLON ty (SOME(ty))
      | (NONE)

fields : label EQ pat
                ((false,[Absyn.PATROWPAT(label,pat,(labelleft,patright))]))
       | label optty optaspat
                ((false,[Absyn.PATROWVAR(label,optty,optaspat,(labelleft,optaspatright))]))
       | PERIODS ((true,nil))
       | label EQ pat COMMA fields
            ((
               #1 fields,
               Absyn.PATROWPAT(label,pat,(labelleft,patright))::(#2 fields)
             ))
       | label optty optaspat COMMA fields 
            ((
               #1 fields,
               Absyn.PATROWVAR
                 (label,optty,optaspat,(labelleft,optaspatright))::(#2 fields)
              ))

optaspat : (NONE)
         | AS pat (SOME(pat))

patseq_comma : pat COMMA pat ([pat1,pat2])
             | patseq_comma COMMA pat (patseq_comma @ [pat])
(* end of pattern *)

(****************  types *********************)
tycon : id_noEQSTAR (id_noEQSTAR)
      | EQ (Symbol.mkSymbol "=" (EQleft,EQright))

tyrow : label COLON ty ([(label,ty)])
      | label COLON ty COMMA tyrow ((label,ty)::tyrow)

ty0 : UNDERBAR (Absyn.TYWILD((UNDERBARleft,UNDERBARright)))
    | tyvar (Absyn.TYID(tyvar,(tyvarleft,tyvarright)))
    | LBRACE tyrow RBRACE (Absyn.TYRECORD(tyrow,(LBRACEleft,RBRACEright)))
    | LBRACE RBRACE (Absyn.TYRECORD([],(LBRACEleft,RBRACEright)))
    | LPAREN ty RPAREN (ty)

ty1 : ty0 (ty0)
    | tyseq tylongid (Absyn.TYCONSTRUCT(tyseq,tylongid,(tyseqleft,tylongidright)))

tyseq : ty1 ([ty1]) 
      | LPAREN tyseq_comma RPAREN (tyseq_comma)
      | (nil)

tyseq_comma : ty COMMA ty ([ty1,ty2])
            | ty COMMA tyseq_comma (ty::tyseq_comma)

tytuple : ty1 ASTERISK tytuple (ty1::tytuple)
        | ty1 ASTERISK ty1 ([ty11,ty12])

ty : ty ARROW ty (Absyn.TYFUN(ty1,ty2,(ty1left,ty2right)))
   | tytuple (Absyn.TYTUPLE(tytuple,(tytupleleft,tytupleright)))
   | ty1 (ty1)

(*
 Ohori; poly_ty and the related definitions are added for rank1 type
  specification
 2007/11/11
*)
poly_tyrow 
      : label COLON poly_ty ([(label,poly_ty)])
      | label COLON poly_ty COMMA poly_tyrow ((label,poly_ty)::poly_tyrow)
      | label COLON poly_ty COMMA tyrow ((label,poly_ty)::tyrow)
      | label COLON ty COMMA poly_tyrow ((label,ty)::poly_tyrow)

poly_ty1 
    : LBRACE poly_tyrow RBRACE (Absyn.TYRECORD(poly_tyrow,(LBRACEleft,RBRACEright)))
    | LPAREN poly_ty RPAREN (poly_ty)
    | LBRACKET kinded_tyvarseq_without_paren PERIOD ty RBRACKET 
         (Absyn.TYPOLY(kinded_tyvarseq_without_paren, ty, (LBRACKETleft,RBRACKETright)))
    | LBRACKET kinded_tyvarseq_without_paren PERIOD poly_ty RBRACKET 
         (Absyn.TYPOLY(kinded_tyvarseq_without_paren, poly_ty, (LBRACKETleft,RBRACKETright)))

poly_tytuple 
    : poly_ty1 ASTERISK poly_tytuple (poly_ty1::poly_tytuple)
    | poly_ty1 ASTERISK tytuple (poly_ty1::tytuple)
    | poly_ty1 ASTERISK poly_ty1 ([poly_ty11,poly_ty12])
    | poly_ty1 ASTERISK ty1 ([poly_ty1, ty1])
    | ty1 ASTERISK poly_tytuple (ty1::poly_tytuple)
    | ty1 ASTERISK poly_ty1 ([ty1,poly_ty1])

poly_ty 
   : ty ARROW poly_ty (Absyn.TYFUN(ty,poly_ty,(tyleft, poly_tyright)))
   | poly_tytuple (Absyn.TYTUPLE(poly_tytuple,(poly_tytupleleft,poly_tytupleright)))
   | poly_ty1 (poly_ty1)

(* Ohori: kinded tyvar added 2007/11/11 ohori *)
kinded_tyvar : tyvar ((tyvar, Absyn.UNIV))
             | TYVAR HASH LBRACE tyrow RBRACE
               (({symbol=Symbol.mkSymbol TYVAR (TYVARleft,TYVARright), eq=Absyn.NONEQ},
                 Absyn.REC(tyrow, (LBRACEleft, RBRACEright))))
             | EQTYVAR HASH LBRACE tyrow RBRACE
               (({symbol=Symbol.mkSymbol EQTYVAR (EQTYVARleft,EQTYVARright),eq=Absyn.EQ},
                 Absyn.REC(tyrow, (LBRACEleft, RBRACEright))))

kinded_tyvarseq : kinded_tyvar ([kinded_tyvar])
         | LPAREN kinded_tyvar RPAREN ([kinded_tyvar])
         | LPAREN kinded_tyvarseq_comma RPAREN (kinded_tyvarseq_comma)

kinded_tyvarseq_comma : kinded_tyvar COMMA kinded_tyvar ([kinded_tyvar1,kinded_tyvar2])
            | kinded_tyvar COMMA kinded_tyvarseq_comma (kinded_tyvar::kinded_tyvarseq_comma)

kinded_tyvarseq_without_paren : kinded_tyvar ([kinded_tyvar])
                | kinded_tyvar COMMA kinded_tyvarseq_without_paren (kinded_tyvar::kinded_tyvarseq_without_paren)
(* kinded tyvar end *)

(****************  end of types *********************)

(*********** foreign function interface *************)

(* 
   Ohori: for error processing, location information is aded to
   ffiApplyArg
*)
ffiApplyArg : appexp COLON ffity
                  (Absyn.FFIARG(appexp, ffity, (appexpleft, ffityright)))
            | SIZEOF LPAREN ty RPAREN
                  (Absyn.FFIARGSIZEOF(ty, NONE, (SIZEOFleft, RPARENright)))
            | SIZEOF LPAREN ty RPAREN ASTERISK atexp
                  (Absyn.FFIARGSIZEOF(ty, SOME atexp, (SIZEOFleft, atexpright)))

ffiApplyArgSeq : ffiApplyArg ([ffiApplyArg])
               | ffiApplyArg COMMA ffiApplyArgSeq (ffiApplyArg::ffiApplyArgSeq)

(* 300 *)
ffiApplyArgs : ([])
             | ffiApplyArgSeq (ffiApplyArgSeq)

(* FFI type representation *)

ffityrow : label COLON ffity ([(label,ffity)])
         | label COLON ffity COMMA ffityrow ((label,ffity)::ffityrow)

ffityseq : ffity COMMA ffity ([ffity1,ffity2])
         | ffity COMMA ffityseq (ffity::ffityseq)

ffiVarArgs : ([])
           | ffity ([ffity])
           | ffity COMMA ffiVarArgs (ffity::ffiVarArgs)
 
ffiArgs : ffiAtty (([ffiAtty], NONE))
        | LPAREN ffityseq RPAREN ((ffityseq, NONE))
        | LPAREN ffity COMMA PERIODS LPAREN ffiVarArgs RPAREN RPAREN
          ([ffity], SOME ffiVarArgs)
        | LPAREN ffityseq COMMA PERIODS LPAREN ffiVarArgs RPAREN RPAREN
          (ffityseq, SOME ffiVarArgs)

ffiContyArg : (nil)
            | ffiAtty ([ffiAtty])
            | LPAREN ffityseq RPAREN (ffityseq)

ffiAtty : LPAREN ffity RPAREN (ffity)
        | tyvar (Absyn.FFITYVAR(tyvar,(tyvarleft,tyvarright)))
        | ffiContyArg tylongid
          (Absyn.FFICONTY(ffiContyArg,tylongid,(ffiContyArgleft,tylongidright)))
        | LBRACE ffityrow RBRACE
          (Absyn.FFIRECORDTY(ffityrow,(LBRACEleft,RBRACEright)))
        | LBRACE RBRACE (Absyn.FFIRECORDTY([],(LBRACEleft,RBRACEright)))

ffitupleseq : ffiAtty ASTERISK ffiAtty ([ffiAtty1,ffiAtty2])
            | ffiAtty ASTERISK ffitupleseq (ffiAtty::ffitupleseq)

ffiTupleTy : ffitupleseq
             (Absyn.FFITUPLETY(ffitupleseq,(ffitupleseqleft,ffitupleseqright)))

ffiFunArg : LPAREN RPAREN (([], NONE))
          | ffiArgs (ffiArgs)
          | ffiTupleTy (([ffiTupleTy], NONE))

ffiFunRet : LPAREN RPAREN ([])
          | ffity ([ffity])
          | LPAREN ffityseq RPAREN (ffityseq)

ffiFunty : ffiFunArg ARROW ffiFunRet
           (Absyn.FFIFUNTY(nil,#1 ffiFunArg,#2 ffiFunArg,ffiFunRet,
                           (ffiFunArgleft,ffiFunRetright)))
         | ffiattr ffiFunArg ARROW ffiFunRet
           (Absyn.FFIFUNTY(ffiattr,#1 ffiFunArg,#2 ffiFunArg,ffiFunRet,
                           (ffiFunArgleft,ffiFunRetright)))

ffiattrseq : ID ([ID])
           | ID COMMA ffiattrseq (ID::ffiattrseq)

ffiattr : ATTRIBUTE LPAREN LPAREN ffiattrseq RPAREN RPAREN (ffiattrseq)

ffiattropt : (nil)
           | ffiattr  (ffiattr)

ffity : ffiAtty (ffiAtty)
      | ffiFunty (ffiFunty)
      | ffiTupleTy (ffiTupleTy)

(*
(* deperecated syntax *)
old_ffiContyArg : (nil)
                | old_ffiAtty ([old_ffiAtty])
                | LPAREN old_ffityseq RPAREN (old_ffityseq)
old_ffiAtty : LPAREN old_ffity RPAREN (old_ffity)
            | old_ffiContyArg tyid
                (Absyn.TYCONSTRUCT(old_ffiContyArg,tyid,(tyidleft,tyidright)))
old_ffituple : old_ffiAtty ASTERISK old_ffiAtty ([old_ffiAtty1,old_ffiAtty2])
             | old_ffiAtty ASTERISK old_ffituple (old_ffiAtty::old_ffituple)
old_ffityseq : old_ffity COMMA old_ffity ([old_ffity1,old_ffity2])
             | old_ffity COMMA old_ffityseq (old_ffity::old_ffityseq)
old_ffityArg : (nil)
             | old_ffity ([old_ffity])
             | old_ffityseq (old_ffityseq)
old_ffiFunty : LBRACE old_ffityArg RBRACE ARROW old_ffity ((old_ffityArg, old_ffity))
old_ffity : old_ffiAtty (old_ffiAtty)
          | old_ffiFunty (Absyn.TYFFI(Absyn.defaultFFIAttributes,nil,
                                      #1 old_ffiFunty,#2 old_ffiFunty,
                                      (old_ffiFuntyleft,old_ffiFuntyright)))
          | old_ffituple (Absyn.TYTUPLE(old_ffituple,(old_ffitupleleft,old_ffitupleright)))
*)

(**************** structure and signature************)

(*----strexp---*)
strexpbasic : STRUCT strdecseq_semicolon END
                (Absyn.STREXPBASIC(strdecseq_semicolon,(STRUCTleft,ENDright)))
            | longid (Absyn.STRID(longid,(longidleft,longidright)))
            | id LPAREN strexp RPAREN
                (Absyn.FUNCTORAPP(id,strexp,(idleft,RPARENright)))
            | id LPAREN strdecseq_semicolon  RPAREN
                (Absyn.FUNCTORAPP
                     (id,Absyn.STREXPBASIC(strdecseq_semicolon,(strdecseq_semicolonleft,strdecseq_semicolonright)),(idleft,RPARENright)))
            | LET strdecseq_semicolon IN strexp END
                (Absyn.STRUCTLET
                     (strdecseq_semicolon,strexp,(LETleft,ENDright)))

strexp : strexpbasic (strexpbasic)
       | strexp COLON sigexp
                (Absyn.STRTRANCONSTRAINT
                     (strexp,sigexp,(strexpleft,sigexpright))) 
       | strexp OPAQUE sigexp
                (Absyn.STROPAQCONSTRAINT
                     (strexp,sigexp,(strexpleft,sigexpright)))
                    
strexpand : strexpbasic AND (strexpbasic)
          | strexp COLON sigexpand
                (Absyn.STRTRANCONSTRAINT
                     (strexp,sigexpand,(strexpleft,sigexpandright))) 
          | strexp OPAQUE sigexpand
                (Absyn.STROPAQCONSTRAINT
                     (strexp,sigexpand,(strexpleft,sigexpandright)))
                   
(*-------------*)

strdecseq_semicolon : strdec strdecseq_semicolon (strdec::strdecseq_semicolon)
                    | SEMICOLON strdecseq_semicolon (strdecseq_semicolon)
                    | ([])

strdec : dec (Absyn.COREDEC(dec,(decleft,decright)))
       | STRUCTURE strbindseq
                (Absyn.STRUCTBIND(strbindseq,(STRUCTUREleft,strbindseqright)))
       | LOCAL strdecseq_semicolon IN strdecseq_semicolon END
                (Absyn.STRUCTLOCAL
                     (strdecseq_semicolon1,strdecseq_semicolon2,(LOCALleft,ENDright)))

(*-----strbind-----*)
strbind : id EQ strexp (Absyn.STRBINDNONOBSERV(id,strexp,(idleft,strexpright)))
        | id COLON sigexp EQ strexp
                (Absyn.STRBINDTRAN(id,sigexp,strexp,(idleft,strexpright)))
        | id OPAQUE sigexp EQ strexp
                (Absyn.STRBINDOPAQUE(id,sigexp,strexp,(idleft,strexpright)))

strbindand : id EQ strexpand
                (Absyn.STRBINDNONOBSERV(id,strexpand,(idleft,strexpandright)))
           | id COLON sigexp EQ strexpand
                (Absyn.STRBINDTRAN
                     (id,sigexp,strexpand,(idleft,strexpandright)))
           | id OPAQUE sigexp EQ strexpand
                (Absyn.STRBINDOPAQUE
                     (id,sigexp,strexpand,(idleft,strexpandright)))

strbindseq : strbind ([strbind])
           | strbindand strbindseq (strbindand::strbindseq)      (*TEST*)

(*---sigexp-----*)
sigexpbasic : SIG spec END (Absyn.SIGEXPBASIC(spec,(SIGleft,ENDright)))
            | id (Absyn.SIGID(id,(idleft,idright)))

sigexpwhere : sigexp WHERE TYPE tyvarseq longid EQ ty
                (Absyn.SIGWHERE
                     (sigexp,(tyvarseq,longid,ty),(sigexpleft,tyright)))
            | sigexp WHERE TYPE longid EQ ty
                (Absyn.SIGWHERE
                     (sigexp,(nil,longid,ty),(sigexpleft,tyright)))
            | sigexpwhere AND TYPE tyvarseq longid EQ ty
                (Absyn.SIGWHERE
                     (sigexpwhere,(tyvarseq,longid,ty),(sigexpwhereleft,tyright)))
            | sigexpwhere AND TYPE longid EQ ty
                (Absyn.SIGWHERE
                     (sigexpwhere,(nil,longid,ty),(sigexpwhereleft,tyright)))


sigexp : sigexpbasic (sigexpbasic)
       | sigexpwhere (sigexpwhere)

sigexpand : sigexpwhere AND (sigexpwhere)
          | sigexpbasic AND (sigexpbasic)

(*---sigexp-----*)
                   
sigbind :id EQ sigexp ([(id,sigexp)])
        |id EQ sigexpand sigbind ((id,sigexpand):: sigbind)        
            
(***********************specifications******************************)

longtyconeqrow : longid EQ longid ([longid1,longid2])
               | longid EQ longtyconeqrow (longid::longtyconeqrow)

longideqrow : longid EQ longid ([longid1,longid2])
            | longid EQ longid EQ longid ([longid1,longid2,longid3])
            | longid EQ longid EQ longideqrow (longid1::longid2::longideqrow)

spec : spec atomicspec
                (Absyn.SPECSEQ(spec,atomicspec,(specleft,atomicspecright)))
     | spec SHARING TYPE longtyconeqrow
                (Absyn.SPECSHARE
                     (spec,longtyconeqrow,(SHARINGleft,longtyconeqrowright)))
     | spec SHARING longideqrow
                (Absyn.SPECSHARESTR
                     (spec,longideqrow,(SHARINGleft,longideqrowright)))
     | spec SEMICOLON (spec)
     | (Absyn.SPECEMPTY)

atomicspec : VAL valdesc
                (Absyn.SPECVAL(valdesc,(VALleft,valdescright)))
           | TYPE typdesc
                (Absyn.SPECTYPE(typdesc,(TYPEleft,typdescright)))
           | TYPE typbind
                (Absyn.SPECDERIVEDTYPE
                   (map stripComment typbind, (TYPEleft,typbindright))
                )
           | EQTYPE typdesc
                (Absyn.SPECEQTYPE(typdesc,(EQTYPEleft,typdescright)))
           | DATATYPE datdesc
                (Absyn.SPECDATATYPE(datdesc,(DATATYPEleft,datdescright)))
           | DATATYPE tycon EQ DATATYPE longid
                (Absyn.SPECREPLIC
                     (tycon,longid,(DATATYPE1left,longidright)))
           | EXCEPTION exdesc
                (Absyn.SPECEXCEPTION(exdesc,(EXCEPTIONleft,exdescright)))
           | STRUCTURE strdesc
                (Absyn.SPECSTRUCT(strdesc,(STRUCTUREleft,strdescright)))
           | INCLUDE SIG spec END
                (Absyn.SPECINCLUDE(Absyn.SIGEXPBASIC(spec,(SIGleft,ENDright)),(INCLUDEleft,ENDright)))
           | INCLUDE sigexpwhere
                (Absyn.SPECINCLUDE(sigexpwhere,(INCLUDEleft,sigexpwhereright)))
           | INCLUDE sigidseq
                (Absyn.SPECDERIVEDINCLUDE
                     (sigidseq,(INCLUDEleft,sigidseqright)))

sigidseq : id ([id1])
             | id sigidseq (id1::sigidseq)
                         
(*
  Ohori: valdesc now take poly_ty
  2007/11/11
*)
valdesc : id COLON poly_ty ([(id,poly_ty)])
        | id COLON ty ([(id,ty)])
        | id COLON poly_ty AND valdesc ((id,poly_ty)::valdesc)
        | id COLON ty AND valdesc ((id,ty)::valdesc)
(* 401 *)

typdesc : tyvarseq tycon ([(tyvarseq, tycon)])
        | tycon ([(nil,tycon)])
        | tyvarseq tycon AND typdesc ((tyvarseq,tycon)::typdesc)
	| tycon AND typdesc  ((nil,tycon)::typdesc)

datdesc : tycon EQ condesc ([(nil,tycon,condesc)])
        | tyvarseq tycon EQ condesc ([(tyvarseq,tycon,condesc)])
        | tycon EQ condesc AND datdesc ((nil,tycon,condesc)::datdesc)
        | tyvarseq tycon EQ condesc AND datdesc
                ((tyvarseq,tycon,condesc)::datdesc)
               
condesc : id ([(id,NONE)])
        | id OF ty ([(id,SOME ty)])
        | id BAR condesc ((id,NONE)::condesc)
        | id OF ty BAR condesc ((id,SOME ty)::condesc)

exdesc : id ([(id,NONE)])
       | id OF ty ([(id,SOME ty)])
       | id AND exdesc ((id,NONE)::exdesc)
       | id OF ty AND exdesc ((id,SOME ty)::exdesc)

strdesc : id COLON sigexp ([(id,sigexp)])
        | id COLON sigexpand strdesc ((id,sigexpand)::strdesc)       

funbindseq : funbind ([funbind])
           | funbindand  funbindseq (funbindand::funbindseq)    
                  
funbind : id LPAREN id COLON sigexp RPAREN EQ strexp
                (Absyn.FUNBINDNONOBSERV
                     (id1,id2,sigexp,strexp,(id1left,strexpright)))
        | id LPAREN id COLON sigexp RPAREN COLON sigexp EQ strexp
                (Absyn.FUNBINDTRAN
                     (id1,id2,sigexp1,sigexp2,strexp,(id1left,strexpright))) 
        | id LPAREN id COLON sigexp RPAREN OPAQUE sigexp EQ strexp
                (Absyn.FUNBINDOPAQUE
                     (id1,id2,sigexp1,sigexp2,strexp,(id1left,strexpright))) 
        | id LPAREN spec RPAREN EQ strexp
                (Absyn.FUNBINDSPECNONOBSERV
                     (id,spec,strexp,(idleft,strexpright)))
        | id LPAREN spec RPAREN COLON sigexp EQ strexp
                (Absyn.FUNBINDSPECTRAN
                     (id,spec,sigexp,strexp,(idleft,strexpright)))
        | id LPAREN spec RPAREN OPAQUE sigexp EQ strexp
                (Absyn.FUNBINDSPECOPAQUE
                     (id,spec,sigexp,strexp,(idleft,strexpright)))

funbindand : id LPAREN id COLON sigexp RPAREN EQ strexpand
                (Absyn.FUNBINDNONOBSERV
                     (id1,id2,sigexp,strexpand,(id1left,strexpandright)))
        | id LPAREN id COLON sigexp RPAREN COLON sigexp EQ strexpand
                (Absyn.FUNBINDTRAN
                     (id1,id2,sigexp1,sigexp2,strexpand,(id1left,strexpandright))) 
        | id LPAREN id COLON sigexp RPAREN OPAQUE sigexp EQ strexpand
                (Absyn.FUNBINDOPAQUE
                     (id1,id2,sigexp1,sigexp2,strexpand,(id1left,strexpandright))) 
        | id LPAREN spec RPAREN EQ strexpand
                (Absyn.FUNBINDSPECNONOBSERV
                     (id,spec,strexpand,(idleft,strexpandright)))
        | id LPAREN spec RPAREN COLON sigexp EQ strexpand
                (Absyn.FUNBINDSPECTRAN
                     (id,spec,sigexp,strexpand,(idleft,strexpandright)))
        | id LPAREN spec RPAREN OPAQUE sigexp EQ strexpand
                (Absyn.FUNBINDSPECOPAQUE
                     (id,spec,sigexp,strexpand,(idleft,strexpandright)))

(*****************************top level declarations**************************)

topdecs : topdec  ([topdec])
        | topdec topdecs (topdec :: topdecs)

topdec : strdec 
                (Absyn.TOPDECSTR(strdec,(strdecleft,strdecright)))
       | SIGNATURE sigbind
                (Absyn.TOPDECSIG(sigbind,(SIGNATUREleft,sigbindright)))
       | FUNCTOR funbindseq
                (Absyn.TOPDECFUN(funbindseq,(FUNCTORleft,funbindseqright)))

useFile : USE STRING (Absyn.USE (Symbol.mkSymbol STRING (USEleft,STRINGright)))
        | USE' STRING (Absyn.USE (Symbol.mkSymbol STRING (USE'left,STRINGright)))

tops : topdecs ([Absyn.TOPDEC topdecs])
     | useFile ([useFile])
     | topdecs useFile tops (Absyn.TOPDEC topdecs :: useFile :: tops)
     | useFile tops (useFile :: tops)

interface : (* none *)
              (Absyn.NOINTERFACE)
          | INTERFACE STRING interface
              (Absyn.INTERFACE (Symbol.mkSymbol STRING (INTERFACEleft, STRINGright)))

unit : interface
         ({interface = interface, tops = nil,
           loc = (interfaceleft, interfaceright)})
     | interface tops
         ({interface = interface, tops = tops,
           loc = (interfaceleft, topsright)})


(***************** SMLFormat specific rules. *************
 The top-level nonterminals:
  1 header_format_comment_list before "type foo = ...", "datatype foo = ...", "exception ..."
  3 defining_format_comment_list before each element; eg. "type foo = *** ty"
 The following is deleted from the original; this is subsumed by header_format_comment_list
  1. inner_header_format_comment_list between "type" and "foo" or "datatype" and "foo"
  2. defining_format_comment_list_with_inners
 The following tags are not imported
  1. prefix
  2. ditto
  3. funheader
  4. destination
*)
(* The toplevel format comments for 
   "type foo = ...", 
   "datatype foo = ..." 
   "abstype ..."
   "exception ..."
  449
*)
header_format_comment_list 
    : ([])
    | FORMATCOMMENTSTART header_format_specs FORMATCOMMENTEND header_format_comment_list
      (header_format_specs :: header_format_comment_list)

header_format_specs 
     :
       ({
        formatters = [],
        params = []
       })
     | ditto_spec header_format_specs  (* dummy *)
       ({
        formatters = #formatters header_format_specs,
        params = #params header_format_specs
       })
     | prefix_spec header_format_specs (* dummy *)
       ({
        formatters = #formatters header_format_specs,
        params = #params header_format_specs
       })
     | destination_spec header_format_specs (* dummy *)
       ({
        formatters = #formatters header_format_specs,
        params = #params header_format_specs
       })
     | funheader_spec header_format_specs  (* dummy *)
       ({
        formatters = #formatters header_format_specs,
        params = #params header_format_specs
       })
     | formatter_spec header_format_specs
       ({
        formatters = formatter_spec :: (#formatters header_format_specs),
        params = #params header_format_specs
       })
     | formatparams_spec header_format_specs
       ({
        formatters = #formatters header_format_specs,
        params = formatparams_spec @ (#params header_format_specs)
       })

formatter_spec : FORMATTERTAG LPAREN patlongid RPAREN patlongid
                 (patlongid1, patlongid2)

formatparams_spec : FORMATPARAMSTAG LPAREN formatparam_list RPAREN
                    (formatparam_list)

formatparam_list : id_noEQSTAR ([id_noEQSTAR])
                 | id_noEQSTAR COMMA formatparam_list (id_noEQSTAR :: formatparam_list)

destination_spec : DESTINATIONTAG STRING (STRING)

funheader_spec : HEADERTAG STRING (STRING)

prefix_spec : PREFIXTAG ID (ID)

ditto_spec : DITTOTAG ID (ID)

prefix_spec_opt : ("")
                | prefix_spec (prefix_spec)



defining_format_comment : FORMATCOMMENTSTART
                          prefix_spec_opt formattag
                          localformattags
                          FORMATCOMMENTEND
                          ({
                             primaryTag = formattag,
                             localTags = localformattags
                           })

defining_format_comment_list 
  : ([])
  | defining_format_comment_list defining_format_comment
    (defining_format_comment_list  @ [defining_format_comment])
  | defining_format_comment_list FORMATCOMMENTSTART FORMATCOMMENTEND
    (defining_format_comment_list)
  | defining_format_comment_list  (* dummy *)
    FORMATCOMMENTSTART
    prefix_spec_opt DITTOTAG
    FORMATCOMMENTEND
    (defining_format_comment_list)

formattag : FORMATTAG LPAREN typepat RPAREN templates
            ({id = NONE, typepat = typepat, templates = templates})
          | FORMATTAG templates (* typepat is dummy *)
            ({id = NONE, 
              typepat = FormatTemplate.VarTyPat {id=Symbol.mkSymbol "_" (FORMATTAGleft,templatesright),loc=(FORMATTAGleft,templatesright)},
              templates = templates})

localformattags : ([])
                | localformattag localformattags
                  (localformattag :: localformattags)

localformattag : FORMATTAG COLON id_noEQSTAR LPAREN typepat RPAREN templates
                ({
                   id = SOME(id_noEQSTAR),
                   typepat = typepat,
                   templates = templates
                 })

typepat : tuple_typepat
          (FormatTemplate.TupleTyPat
             {elements=tuple_typepat, 
              loc=(tuple_typepatleft, tuple_typepatright)}
            )
        | typepat' (typepat')

tuple_typepat : typepat' ASTERISK tuple_typepat (typepat' :: tuple_typepat)
              | typepat' ASTERISK typepat' ([typepat'1, typepat'2])

typepat' : LBRACE typepat_rows RBRACE
           (FormatTemplate.RecordTyPat
              {fields = #1 typepat_rows,
               flex = #2 typepat_rows,
               loc=(LBRACEleft, RBRACEright)
              }
           )
         | LBRACE RBRACE
           (FormatTemplate.RecordTyPat
              {fields=[], 
               flex=false, 
               loc=(LBRACEleft, RBRACEright)})
         | LPAREN typepat RPAREN
           (typepat)
         | atypepat 
           (atypepat)

atypepat : LPAREN atypepat_list RPAREN id_noEQSTAR
           (FormatTemplate.TyConTyPat
              {conid=id_noEQSTAR, 
               args=atypepat_list, 
               loc=(LPARENleft, id_noEQSTARright)}
           )
         | LPAREN atypepat_list RPAREN id_noEQSTAR COLON id_noEQSTAR
           (FormatTemplate.TypedTyConTyPat
              {conid=id_noEQSTAR1, 
               args=atypepat_list,
               typid=id_noEQSTAR2, 
               loc=(LPARENleft,id_noEQSTARright)}
           )
         | atypepat id_noEQSTAR
           (FormatTemplate.TyConTyPat
              {conid = id_noEQSTAR, 
               args=[atypepat],
               loc=(atypepatleft,id_noEQSTARright)
              }
           )
         | atypepat id_noEQSTAR COLON id_noEQSTAR 
           (FormatTemplate.TypedTyConTyPat
              {conid=id_noEQSTAR1, 
               args=[atypepat],
               typid=id_noEQSTAR2,
               loc=(atypepatleft,id_noEQSTARright)}
           )
         | id_noEQSTAR 
            (FormatTemplate.VarTyPat {id=id_noEQSTAR, 
                                      loc=(id_noEQSTARleft, id_noEQSTARright)}
             )
         | id_noEQSTAR COLON id_noEQSTAR
            (FormatTemplate.TypedVarTyPat
              {conid=id_noEQSTAR1, 
               typid=id_noEQSTAR2, 
               loc=(id_noEQSTAR1left,id_noEQSTAR2right)}
            )
         | UNDERBAR 
            (FormatTemplate.WildTyPat {loc=(UNDERBARleft,UNDERBARright)})

atypepat_list : atypepat COMMA atypepat_list (atypepat :: atypepat_list)
              | atypepat COMMA atypepat ([atypepat1, atypepat2])

typepat_rows : typepat_field COMMA typepat_rows
               ((typepat_field :: (#1 typepat_rows), #2 typepat_rows))
             | typepat_field (([typepat_field], false))
             | PERIODS (([], true))

typepat_field : label (label, (FormatTemplate.VarTyPat {id=Symbol.mkSymbol label (labelleft,labelright), loc=(labelleft,labelright)}))
              | label COLON typepat (label, typepat)

templates : template templates (template :: templates)
          | STARTOFINDENT templates RBRACKET templates
             (
              FormatTemplate.StartOfIndent 
                {indent=STARTOFINDENT,
                 loc=(STARTOFINDENTleft, templatesright)
                }
              ::
              templates1
              @
              FormatTemplate.EndOfIndent {loc=(RBRACKETleft, RBRACKETright)}
              ::
              templates2
             )
          | ([])

template : STRING 
           (FormatTemplate.Term {string=STRING, loc=(STRINGleft, STRINGright)})
         | NEWLINE
           (FormatTemplate.Newline {loc=(NEWLINEleft, NEWLINEright)})
         | ASSOCINDICATOR LBRACE templates RBRACE
           (
            FormatTemplate.Guard
              {assocOpt = SOME(ASSOCINDICATOR), 
               templates=templates,
               loc= (ASSOCINDICATORleft, RBRACEright)
              }
           )
         | LBRACE templates RBRACE
           (FormatTemplate.Guard
              {assocOpt = NONE, 
               templates=templates,
               loc= (LBRACEleft, RBRACEright)
              }
           )
         | FORMATINDICATOR
           (
            FormatTemplate.Indicator
             {
              space = #space FORMATINDICATOR,
              newline = #newline FORMATINDICATOR,
              loc=(FORMATINDICATORleft,FORMATINDICATORright)
             }
           )
         | inst
           (FormatTemplate.Instance inst)
(* 500 *)

inst : id_noEQSTAR opt_typed
       (FormatTemplate.Atom {id=id_noEQSTAR, optId=opt_typed, loc=(id_noEQSTARleft, opt_typedright)})
     | id_noEQSTAR opt_typed LPAREN insts RPAREN LPAREN templates_comma_list RPAREN
       (FormatTemplate.App 
          {id=id_noEQSTAR, 
           optId=opt_typed, 
           args=insts, 
           templates=templates_comma_list,
           loc=(id_noEQSTARleft, RPARENright)
          }
       )
     | id_noEQSTAR opt_typed LPAREN RPAREN LPAREN templates_comma_list RPAREN
       (FormatTemplate.App 
          {id=id_noEQSTAR, 
           optId=opt_typed, 
           args=[], 
           templates=templates_comma_list,
           loc=(id_noEQSTARleft, RPARENright)
          }
       )
     | id_noEQSTAR opt_typed LPAREN insts RPAREN
       (
        FormatTemplate.App
          {id=id_noEQSTAR, 
           optId=opt_typed, 
           args=insts, 
           templates=[],
           loc=(id_noEQSTARleft, RPARENright)
          }
        )
     | id_noEQSTAR opt_typed LPAREN RPAREN
       (
        FormatTemplate.App
          {id=id_noEQSTAR,
           optId=opt_typed,
           args=[], 
           templates=[],
           loc=(id_noEQSTARleft, RPARENright)
          }
       )

opt_typed : (NONE)
          | COLON id_noEQSTAR
            (SOME(id_noEQSTAR))

insts : inst COMMA insts (inst :: insts)
      | inst ([inst])

templates_comma_list : templates COMMA templates_comma_list
                       (templates :: templates_comma_list)
                     | templates ([templates])

